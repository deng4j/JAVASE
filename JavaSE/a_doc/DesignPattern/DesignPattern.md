# 一.设计模式7大原则

## 1.开闭原则

(Open-Closed Principle, OCP) 定义：

- 对扩展开放，对修改关闭。

降低维护带来的新风险。

**实现方法**： 通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。

## 2.里氏替换原则

 (Liskov Substitution Principle, LSP) 定义：

- **所有引用基类 （父类）的地方必须能透明地使用其子类的对象。**（在软件中将一个基类对象替换成它的子类对象，程序将不会产生任 何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。）

  意思是，继承必须确保超类所拥有的性质在子类中仍然成立（**子类可以扩展父类的功能，但不能改变父类原有的功能**。）

里氏替换原则是继承复用的基础，它反映了基类与子类之间的关系，是实现开闭原则的重要方式之一，是对实现抽象化的具体步骤的规范。

里氏替换原则的定义可以总结如下：

- 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
- 子类中可以增加自己特有的方法
- 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松
- 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等

## 3.依赖倒置原则

(Dependence Inversion Principle, DIP) 定义：

- 高层模块不应该依赖低层模块，两者都应该依赖其抽象；
- 抽象不应该依赖细节，细节应该依赖抽象。

**核心思想是：要面向接口编程，不要面向实现编程, 降低类间的耦合性**

**依赖倒置原则的主要作用如下:**

- 依赖倒置原则可以降低类间的耦合性。
- 依赖倒置原则可以提高系统的稳定性。
- 依赖倒置原则可以减少并行开发引起的风险。
- 依赖倒置原则可以提高代码的可读性和可维护性。

**依赖倒置原则的实现方法:**

- 每个类尽量提供接口或抽象类，或者两者都具备。
- 变量、方法返回类型的声明类型尽量是接口或者是抽象类。
- 任何类都不应该从具体类派生。
- 使用继承时尽量遵循里氏替换原则。

## 4.单一职责原则

(Single Responsibility Principle, SRP) ：

- 一个类只负责一个功能领域中的相应职责，否则类应该被拆分。

## 5.接口隔离原则

(Interface Segregation Principle, ISP) 定义：

- 要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。

**实现方法**：

- 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
- 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
- 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。
- 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。

## 6.迪米特法则

迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)

定义：

- 只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。意思是如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用，如方法参数。其目的是降低类之间的耦合度，提高模块的相对独立性。

如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。

迪米特法则中的“朋友”是指：

- 当前对象本身(this)；
- 以参数形式传入到当前对象方法中的对象；
- 当前对象的成员对象；
- 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； 
- 当前对象所创建的对象。

运用迪米特法则时要注意以下 6 点:

- 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
- 在类的结构设计上，尽量降低类成员的访问权限。
- 在类的设计上，优先考虑将一个类设置成不变类。
- 在对其他类的引用上，将引用其他对象的次数降到最低。
- 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。
- 谨慎使用序列化（Serializable）功能。

## 7.合成复用原则

合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。

定义：

- 它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。
- 如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。

在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/ 聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低 类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使 用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂 度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。 

通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实 现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白 箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是 静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用 （如类没有声明为不能被继承）。 

由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。 

一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继 承。"Is-A"是严格的分类学意义上的定义，意思是一个类是另一个类的"一种"；而"Has-A"则不 同，它表示某一个角色具有某一项责任。

# 二.设计心得

==接口是对动作的抽象，表达的是 like a 的关系；抽象类是对根源的抽象，表达的是 is a 的关系。==

![ArrayList-1-768x406-1](assist/ArrayList-1-768x406-1.png)

- **公共的特性**尽可能在高层中加入，如List接口在AbstractList中实现，而不应该在ArrayList中实现。当你不确定会不会出现不需要该**特性**的具体实现类时，不应该设为公共特性。

  > 类似问题：HashMap既然继承了AbstractMap为什么还要实现Map？
  >
  > java集合框架的创始人Josh Bloch描述，这样的写法是一个失误。
  >
  > [java - Why does LinkedHashSet extend HashSet and implement Set - Stack Overflow](https://stackoverflow.com/questions/2165204/why-does-linkedhashsete-extend-hashsete-and-implement-sete)

- 抽象类应该实现所有具体实现类的公共细节，如AbstractList中的迭代器。

- 抽象类中尽可能不设置成员属性，你所有需要的东西，都可以在抽象方法的返回值中得到。

- 抽象类具体实现方法应该设计为抽象方法，让具体实现类实现细节。

  ```java
  public abstract int size();
  
  public boolean add(E e){
    add(size(), e);
    return true;
  }
  ```

- 对于同一种方法，使用方法重载。"实现细节"在参数复杂的方法中实现。其他的简单方法只需要看情况调用这个实现方法即可。

  ```java
  public boolean add(E e){
    add(size(), e);
    return true;
  }
  
  public abstract boolean add(int index, E e);
  ```
