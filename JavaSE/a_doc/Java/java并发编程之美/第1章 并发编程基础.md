# 一.并发编程基础

## 1.并发、并行

**CPU与线程**：

在CPU眼里，没有进程的概念，一个CPU同一时刻只能执行一个线程，不管是哪个进程的，所以一个进程下的多个线程可以在不同CPU同时执行。真正要占用CPU运行的是线程，所所以也说线程是CPU分配的基本单位。

操作系统是为每个线程分配一个时间片来使用CPU，正常情况下当一个线程把分配给自己的时间片使用完后，线程调度器才会进行下一轮的线程调度。

所以在单 CPU 时代多线程编程是没有太大意义的，并且线程间频繁的上下文切换还会带来额外开销。

**并发**：当有多个线程在操作时，如果系统只有一个CPU，只能把CPU运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。这种方式我们称之为并发(Concurrent)。

**并行：**当系统有多个CPU时，则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。

## 2.进程、线程

在Java中，当我们启动main函数时其实就启动了一个口！M的进程，而main函数所 在的线程就是这个进程中的一个线程，也称主线程。

![QQ截图20230916173413](assist\QQ截图20230916173413.png)

一个进程中有多个线程，多个线程共享进程的堆和方法区资源， 但是每个线程有自己的程序计数器和栈区域。

- 堆：进程的一个资源区，被该进程的所有线程共享，存储对象实例。
- 方法区：存放JVM加载的类、常量及静态变量等信息，也是线程共享的。

- 程序计数器：用来记录线程当前要执行的指令地址。线程从挂起到运行态，cpu要知道从哪个位置开始执行。

  另外需要注意的是，如果执行的是native方法， 那么pc计数器记录的是undefined地址，只有执行的是Java代码时pc计数器记录的才是 下一条指令的地址。

- 栈：用于存储该线程的局部变量，还用来存放线程的调用栈帧。

## 3.线程的生命周期

![QQ20230813-120815@2x](assist\QQ20230813-120815@2x.png)

### 3.1 线程状态

- NEW：初始状态，线程被构建，但是还没有调用 start()方法。
- RUNNABLE：可运行状态，包括：**运行中状态**和**就绪状态**。
- BLOCKED：阻塞状态，处于这个状态的线程需要等待其他线程释放锁或者等待进入 synchronized。 
- WAITING：表示等待状态，处于该状态的线程需要等待其他线程对其进行通知或中断等操作，进而进入下一个状态。
- TIME_WAITING：超时等待状态。可以在一定的时间自行返回。
- TERMINATED：终止状态，当前线程执行完毕。

### 3.2 方法

**object方法**：

- **wait()**：当一个线程调用一个共享变量的wait()方法时，该调用线程会被阻塞挂起，进入等待队列，并释放该线程所拥有的锁，直到发生下面几件事之一才返回：

  1. 其他线程调用了该共享对象的notify()或者notifyAll()方法；
  2. 其他线程调用了该线程的interrupt()方法，该线程抛出InterruptedException异常返回。

  注意：

  1. 如果调用wait方法的线程没有事先获取该对象的**监视器锁**，则调用wait()方法时调用线程会抛出IllegalMonitorStateException异常。所以一般在同步代码块中使用。

     ```java
     # 使用该共享变量作为参数。
     synchronized（共享变量）｛
         // do something
     }
     
     # 调用该共享变量的方法，并且该方法使用了synchronized修饰。
     synchronized void add （工nta, int b) { 
     	//do something 
     }
     ```

  2. 一个线程可以从挂起状态变为可以运行状态（也就是被唤醒），即使该线程没有被其他线程调用notify()、notifyAll()方法进行通知，或者被中断，或者等待超时，这就是所谓的虚假唤醒。

     虽然虚假唤醒在应用实践中很少发生，但要防患于未然。

     ```java
     synchronized (obj) { 
     	if (条件) {
     		obj.wait();
         }
     }
     ```

- wait(long timeout）：多了一个超时参数。

  如果一个线程调用共享对象的该方法挂起后，没有在指定的timeoutms时间内被其他线程调用该共享变量的 notify（）或者notifyAll（）方法唤醒，那么该函数还是会因为超时而返回。

  timeout为0则和wait()方法一样，因为wait()方法内部就是调用了wait(0)；如果为负数，则抛Illega!ArgumentException异常。

- wait(long timeout, int nanos）：内部调用的是wait(long timeout），只有nanos>0时才使参数 timeout递增1。

- notify（）：一个线程调用共享对象的notify（）方法后，会**随机**唤醒一个**在该共享变量上**调用wait系列方法后被挂起的线程。

  被唤醒的线程不能马上从wait方法返回并继续执行，它**必须等获取了共享对象的监视器锁后才可以**；也就是说，被唤醒后要竞争到锁后才可以继续执行。

  注意：类似wait，只有当前线程获取到了共享变量的监视器锁后，才可以调用共享变量的notify（）方法，否则会抛出IllegalMonitorStateException异常。

- notifyAll（）：会唤醒**所有**在该共享变量上由于调用wait系列方法而被挂起的线程。

---

**Thread方法：**

- **start()**：开始一个线程。

  调用start方法后线程并没有马上执行而是处于**就绪状态**，这个就绪状态是指该线程已经获取了除CPU资源外的其他资源，等待获取CPU资源后才会真正处于**运行状态**。

- **join（）**：A线程执行了B线程调用join（）方法，A线程会等到B线程执行完毕才能执行。这时候，当其他线程调用了线程A的 interrupt（）方法中断了线程A时，线程A会抛出InterruptedException异常而返回。

- **sleep（）**：调用了Thread的sleep()方法的线程会暂时让出指定时间的执行权，但是该线程所拥有的监视器资源，比如锁还是持有不让出的。

  指定的睡眠时间到了后该函数会正常返回，线程就处于就绪状态，然后参与CPU的调度，获取到CPU资源后就可以继 续运行了。

  如果在睡眠期间其他线程调用了该线程的interrupt（）方法中断了该线程，则该线程会在调用sleep方法的地方抛出IntermptedException异常而返回。

- **yield（）**：当一个线程调用yield方法时，实际就是在暗示线程调度器，**请求让出自己的CPU使用**，可以进行下一轮线程调度了，但是线程调度器可以无条件忽略这个暗示。

  线程调用yield方法时，当前线程会让出CPU使用权，然后处于就绪状态，线程调度器会从线程就绪队列里面获取一个线程优先级最高的线程，当然也有可能会调度到 刚刚让出CPU的那个线程来获取CPU执行权。

Java中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。

- **void interrupt（）**：中断线程。当线程A运行时，线程B可以调用线程A的interrupt()方法来**设置线程A的中断标志为true**并立即返回。

  设置标志仅仅时设置标志，实际上线程A并没有被中断，会继续执行。

  如果线程A因为调用了 wait系列函数、join方法或者sleep方法而被阻塞挂起，这时候若线程B调用线程A的interrupt（）方法，线程A会在调用这些方法的地方抛出InterruptedException异 常而返回。

- **boolean isinterrupted（）**：检测**当前线程**是否被中断，如果是返回true，否则返回false。

- **boolean interrupted**（）：检测**当前线程**是否被中断，如果是返回true，否则返回false。

  不同的是，该方法如果发现当前线程被中断，则会清除中断标志，并且**该方法是static方法**，可以通过Thread类直接调用。所以这个”当前线程“是指执行interrupted（）的线程。

## 4.线程上下文切换

一个CPU同一时刻只能被一个线程使用，CPU资源采用时间片轮转的策略给线程分配执行时间。

线程使用完后，就会处于就绪状态，并让出CPU让其他线程使用，这就是上下文切换。

上下文切换时机：

- 时间片用完。
- 当前线程被其他线程中断。

## 5.线程死锁

指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象， 在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。

![QQ截图20230916230329](assist\QQ截图20230916230329.png)

死锁的产生必须具备以 下四个条件：

1. 互斥条件：线程已获得的资源同一时间只有一个线程占用。
2. 请求并持有条件：一个线程持有至少一个资源，但又请求新资源，而新资源被另一个线程占有，所以当前线程被阻塞，但阻塞的同时并不能释放自己已获取的资源。
3. 不可剥夺条件：线程获得的资源在使用完之前不能被其他线程抢占。
4. 环路等待条件：发生死锁时，必然存在一线程一资源的环形链。

## 6.守护线程与用户线程

java线程分为两类：daemon线程（守护线程）、user线程（用户线程）

在NM启动时会调用main函数，main函数所在的钱程就是一个用户线程，其实在JVM 内部同时还启动了好多守护线程，比如垃圾回收线程。

当最后一个非守护线程结束时，JVM会正常退出，而不管当前是否有守护线程。

## 7.Thread Local 

ThreadLocal内部维护了一个map，当要set值的时候，**以当前线程**作为key，所以每次get都是当前线程的资源。

**ThreadLocal 内存泄漏**：

![QQ20230731-154125@2x](assist\QQ20230731-154125@2x.png)

`ThreadLocal`是一个弱引用，当为`null`时，会被当成垃圾回收 。

**假如我们ThreadLocal是null了，也就是要被垃圾回收器回收了，但是此时我们的ThreadLocalMap（thread 的内部属性）生命周期和Thread的一样，它不会回收，这时候就出现了一个现象。那就是ThreadLocalMap的key没了，但是value还在，这就造成了内存泄漏。**

解决办法：使用完`ThreadLocal`后，执行`remove`操作，避免出现内存溢出情况。

**为什么key使用弱引用？**

如果使用强引用，当`ThreadLocal` 对象的引用（强引用）被回收了，`ThreadLocalMap`本身依然还持有`ThreadLocal`的强引用，如果没有手动删除这个key ,则`ThreadLocal`不会被回收，所以只要当前线程不消亡，`ThreadLocalMap`引用的那些对象就不会被回收， 可以认为这导致`Entry`内存泄漏。

**Threadlocal不支持继承性**

同一个ThreadLocal变量在父线程中被设置值后，在子线程中是获取不到的。

那么有没有办法让子线程能访问到父线程中的值？

**lnheritableThreadLocal类**

继承自ThreadLocal，其提供了一个特性，就是让子线程可以访问在父线程中设置的本地变量。

InheritableThreadLocal的世界里，变量inheritableThreadLocals替代了 threadLocals。

在Thread构造方法中：

```java
if (inheritThreadLocals && parent.inheritableThreadLocals != null)
            this.inheritableThreadLocals =
            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
```

如果父线程的inheritableThreadLocals不为null，则以父线程的inheritableThreadLocals创建一个副本给子线程











