package dzh.com.DesignPattern.DesignPattern.structuralPatterns.composite.fileSearch;

/**
 * 组合模式：把部分和整体的关系用树形结构来表示，从而是客户端可以使用统一的方式处理部分对象和整体对象
 *
 * 主要优点：
 *  1.组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。
 *  2.客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。
 *  3.在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”。
 *  4.组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。
 *
 * 主要缺点:在增加新构件时很难对容器中的构件类型进行限制。有时候我们希望一个容器中只能有某些特定类型的对象，
 * 例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，
 * 在这种情况下，必须通过在运行时 进行类型检查来实现，这个实现过程较为复杂。
 *
 * 适用场景:
 *  1.在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以 一致地对待它们。
 *  2.在一个使用面向对象语言开发的系统中需要处理一个树形结构。
 *  3.在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新 的类型。
 */

/**
 * 抽象组件：定义了叶子和容器构件的共同点
 */
public interface Component {
    void operation();
}

/**
 * Leaf（叶子构件）：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。
 * 对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。
 */

interface Leaf extends Component {

}

/**
 * Composite（容器构件）：它在组合结构中表示容器节点对象，容器节点包含子节点，其子 节点可以是叶子节点，
 * 也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象 构件中定义的行为，包括那些访问及管理子构件的方法，
 * 在其业务方法中可以递归调用其子节点的业务方法。
 */
interface Composite extends Component {
    void add(Component c);

    void remove(Component c);

    Component getChild(int index);
}

