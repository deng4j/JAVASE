缓存一致性问题：
更新数据库成功——>更新缓存失败  ——>数据不一致
更新缓存成功  ——>更新数据库失败——>数据不一致
更新数据库成功——>淘汰缓存失败  ——>数据不一致
淘汰缓存成功  ——>更新数据库失败——>查询缓存miss

缓存并发问题：
缓存过期后会尝试从数据库获取数据，在高并发场景下多个请求并发从数据库获取数据，
对数据库造成极大的冲击，甚至导致缓存雪崩。此外，当某个缓存的key被更新时，同时
可能被多个请求获取，也会造成缓存一致性问题。
解决：锁机制，在缓存更新或者过期情况下先尝试获取锁，让更新或从数据库获取完成
后再释放锁，其他请求只需要牺牲一点等待时间便可继续从缓存中获取数据。

缓存穿透：
在高并发场景下如果某一个key被高并发的访问，没有被命中。出于对容错性的考虑，尝试
从数据库去获取，从而导致大量请求达到了数据库。而当该key本身就是空的情况下，导致
数据库并发的去执行一些不必要的操作，从而产生巨大的冲击和压力。
解决：
    1.缓存空对象：
        对查询结果为空的对象也进行缓存，如果是集合，可以缓存一个空集合，而不是null。
        如果缓存单个对象，可以使用字段标识来区分，避免请求穿透到数据库，保证缓存数据的
        时效性。
    2.单独过滤处理：对所有对应数据可能为null的数据进行统一的数据存放，并在请求前做拦截。

缓存颠簸：
是比缓存雪崩更轻微的现象，但也会对数据库造成一定的冲击。一般是由缓存节点出现故障导致。
解决：通过一致性hash算法来解决。

缓存雪崩：
由于缓存的原因导致大量请求到达数据库，从而导致数据库崩溃。
    原因：缓存并发，缓存穿透，缓存颠簸，某个时间点内系统预加载的缓存周期性的集中失效了。
解决：限流，降级，熔断，多级缓存，Hystrix等


限流：
    计数器算法：存在临界点问题。
    滑块算法：就是包含多个计数器算法，所需内存较大。
    漏桶算法：漏桶算法能够强行限制数据的传输速率。
    令牌漏桶算法： 令牌桶算法能够在限制数据的平均传输速率的同时还允许某种程度的突发传输。

        在某些情况下，漏桶算法不能够有效地使用网络资源。因为漏桶的漏出速率是固定的，
        所以即使网络中没有发生拥塞，漏桶算法也不能使某一个单独的数据流达到端口速率。
        因此，漏桶算法对于存在突发特性的流量来说缺乏效率。而令牌桶算法则能够满足这些
        具有突发特性的流量。通常，漏桶算法与令牌桶算法结合起来为网络流量提供更高效的控制。


服务降级：
    当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种
    简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。

    自动降级：超时，失败次数，故障，限流。
    人工降级：秒杀，双11。


服务熔断：
    考试过程中当断则断的方式，正好符合微服务架构中的一种安全机制：【熔断】。
    在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了
    保护系统整体的可用性，可以暂时切断对下游服务的调用。